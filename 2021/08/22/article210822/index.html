<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Kotlin标准函数和静态方法"><meta name="keywords" content="Kotlin,学习笔记"><meta name="author" content="PrePan"><meta name="copyright" content="PrePan"><title>Kotlin标准函数和静态方法 | 你知道PrePan吗？</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换至文章">切换至导航</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目 录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">标准函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#let"><span class="toc-number">1.1.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#also"><span class="toc-number">1.2.</span> <span class="toc-text">also</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#with"><span class="toc-number">1.3.</span> <span class="toc-text">with</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#run"><span class="toc-number">1.4.</span> <span class="toc-text">run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply"><span class="toc-number">1.5.</span> <span class="toc-text">apply</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD"><span class="toc-number">2.1.</span> <span class="toc-text">曲线救国</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">真正的静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.1.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">顶层方法</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.ibb.co/wYT1gkG/QQ-20210619213219.png"></div><div class="author-info__name text-center">PrePan</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">欢迎关注！</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://space.bilibili.com/12667178">Bilibili</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://weibo.com/u/3155053641">Weibo</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://z3.ax1x.com/2021/08/18/fIYaY6.png">CoolApk</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.douban.com/people/PrePan/">Douban</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/pk/wallhaven-pkw6y3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">你知道PrePan吗？</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/information">简介</a><a class="site-page" href="/tags">分类</a><a class="site-page" href="/archives">文章</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Kotlin标准函数和静态方法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-22</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">1.2k</span><span class="post-meta__separator">|</span><span>Reading time: 4 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h1><p>任何Kotlin代码可以自由调用所有标准函数，这些函数定义在Stand.kt文件中。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a><code>let</code></h2><p><strong>作用：</strong><code>let</code>函数提供了函数式API的编程接口，并将原始调用对象作为参数传递到Lambda表达式中。</p>
<p><strong>应用：</strong>省去写判空操作</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123; obj2 -&gt;</span><br><span class="line">	// 逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 使用Java</span><br><span class="line">if( mVar != null )&#123;</span><br><span class="line">    mVar.function1();</span><br><span class="line">    mVar.function2();</span><br><span class="line">    mVar.function3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用kotlin（无使用let函数）</span><br><span class="line">mVar?.function1()</span><br><span class="line">mVar?.function2()</span><br><span class="line">mVar?.function3()</span><br><span class="line"></span><br><span class="line">// 使用kotlin（使用let函数）</span><br><span class="line">// 方便了统一判空的处理 &amp; 确定了mVar变量的作用域</span><br><span class="line">mVar?.let &#123;</span><br><span class="line">       it.function1()</span><br><span class="line">       it.function2()</span><br><span class="line">       it.function3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="also"><a href="#also" class="headerlink" title="also"></a><code>also</code></h2><p><strong>作用：</strong>类似let函数，但区别在于返回值：返回值 = 最后一行 / return的表达式</p>
<p><strong>例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// let函数</span><br><span class="line">var result = mVar.let &#123;</span><br><span class="line">               it.function1()</span><br><span class="line">               it.function2()</span><br><span class="line">               it.function3()</span><br><span class="line">               999</span><br><span class="line">&#125;</span><br><span class="line">// 最终结果 = 返回999给变量result</span><br><span class="line"></span><br><span class="line">// also函数</span><br><span class="line">var result = mVar.also &#123;</span><br><span class="line">               it.function1()</span><br><span class="line">               it.function2()</span><br><span class="line">               it.function3()</span><br><span class="line">               999</span><br><span class="line">&#125;</span><br><span class="line">// 最终结果 = 返回一个mVar对象给变量result</span><br></pre></td></tr></table></figure>

<h2 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h2><p><strong>作用：</strong><code>with</code>函数接受两个参数：<strong>一个任意类型的对象</strong>、<strong>一个Lambda表达式</strong>。<code>with</code>函数会在Lambda表达式中提供第一个参数对象的上下文，并使用Lambda表达式中的最后一行代码作为返回值返回。</p>
<p><strong>应用：</strong>需要调用同一个对象的多个方法 / 属性</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = with(obj)&#123;</span><br><span class="line">	//obj上下文</span><br><span class="line">	&quot;value&quot; //with函数的返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 此处要调用people的name和age属性</span><br><span class="line">// kotlin</span><br><span class="line">val people = People(&quot;carson&quot;, 25)</span><br><span class="line">with(people) &#123;</span><br><span class="line">println(&quot;my name is $name, I am $age years old&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line">User peole = new People(&quot;carson&quot;, 25);</span><br><span class="line">String var1 = &quot;my name is &quot; + peole.name + &quot;, I am &quot; + peole.age + &quot; years old&quot;;</span><br><span class="line">System.out.println(var1);</span><br></pre></td></tr></table></figure>

<h2 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h2><p><strong>作用：</strong><code>run</code>函数与<code>with</code>函数非常类似，但不会直接调用，要在某个对象的基础上调用。<code>run</code>函数只接收一个Lambda参数，并且会在Lambda表达式中提供调用对象的上下文。</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = obj.run &#123;</span><br><span class="line">	//obj上下文</span><br><span class="line">	&quot;value&quot; //run函数的返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例子2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 此处要调用people的name 和 age属性，且要判空</span><br><span class="line">// kotlin</span><br><span class="line">val people = People(&quot;carson&quot;, 25)</span><br><span class="line">people?.run&#123;</span><br><span class="line">    println(&quot;my name is $name, I am $age years old&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line">User peole = new People(&quot;carson&quot;, 25);</span><br><span class="line">String var1 = &quot;my name is &quot; + peole.name + &quot;, I am &quot; + peole.age + &quot; years old&quot;;</span><br><span class="line">System.out.println(var1);</span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a><code>apply</code></h2><p><strong>作用：</strong>与run函数类似，区别在返回值，<code>apply</code>函数无法指定返回值，而是会自动返回调用对象本身。</p>
<p><strong>例子1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val result = obj.apply&#123;</span><br><span class="line">	//obj上下文</span><br><span class="line">&#125;</span><br><span class="line">// result == obj</span><br></pre></td></tr></table></figure>


<p><strong>例子2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// run函数</span><br><span class="line">val people = People(&quot;carson&quot;, 25)</span><br><span class="line">val result = people?.run&#123;</span><br><span class="line">    println(&quot;my name is $name, I am $age years old&quot;)</span><br><span class="line">    999</span><br><span class="line">&#125;</span><br><span class="line">// 最终结果 = 返回999给变量result</span><br><span class="line"></span><br><span class="line">// apply函数</span><br><span class="line">val people = People(&quot;carson&quot;, 25)</span><br><span class="line">val result = people?.apply&#123;</span><br><span class="line">    println(&quot;my name is $name, I am $age years old&quot;)</span><br><span class="line">    999</span><br><span class="line">&#125;</span><br><span class="line">// 最终结果 = 返回一个people对象给变量result</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong><br><img src="https://z3.ax1x.com/2021/08/23/hpLzvR.md.png"></p>
<h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><h2 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h2><p>Java中定义静态方法只需要在方法上声明static即可，但Kotlin极度弱化了静态方法的概念，Kotlin提供了比静态方法更好用的语法特性：<strong>单例类</strong>！</p>
<p>在Kotlin中创建单例十分简单,只需要将class改为object就可以,当然,studio也提供创建单例类的方式,创建类型选择Object就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Singleton &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，单例类的写法会让整个类中所有方法全部变成类似于静态方法的调用方法，如果只希望让类中的某一个方法变成静态方法的调用方法怎么办呢？<br>可以使用<strong>companion object</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Util&#123;</span><br><span class="line">	</span><br><span class="line">	fun doAction1()&#123;	//一定要创建Util实例才能调用</span><br><span class="line">		println(&quot;doAction1&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	companion object&#123;	//在Util类中创建一个伴生类，可直接调用</span><br><span class="line">		fun doAction2()&#123;</span><br><span class="line">			println(&quot;doAction2&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="真正的静态方法"><a href="#真正的静态方法" class="headerlink" title="真正的静态方法"></a>真正的静态方法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在前面的companion object中的方法加上**@JvmStatic**注解，Kotlin编译器会将这些方法编译成真正的静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Util&#123;</span><br><span class="line">	</span><br><span class="line">	fun doAction1()&#123;</span><br><span class="line">		println(&quot;doAction1&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	companion object&#123;</span><br><span class="line">		@JvmStatic</span><br><span class="line">		fun doAction2()&#123;</span><br><span class="line">			println(&quot;doAction2&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@JvmStatic注解只能加在单例类或companion object中的方法上！加在普通方法上会报错。</strong></p>
<h3 id="顶层方法"><a href="#顶层方法" class="headerlink" title="顶层方法"></a>顶层方法</h3><p>顶层方法之那些没有定义在任何类中的方法。Kotlin编译器会将所有顶层方法编译成静态方法。</p>
<p>定义一个顶层方法，先创建一个类型为File的Kotlin文件，在这个文件中定义的所有方法都是顶层方法。</p>
<p>所有的顶层方法可以在任意位置被直接调用，不用管包名路径，不用创建实例。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kotlin/">Kotlin</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/25/article210825/"><i class="fa fa-chevron-left">  </i><span>Kotlin扩展函数和运算符重载</span></a></div><div class="next-post pull-right"><a href="/2021/08/19/%E5%88%A9%E7%94%A8PR%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E5%86%85%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C/"><span>利用PR制作视频内进度条效果</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = '' == 'true';
var verify = '' == 'true';
var record_ip = 'true' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'gYtzDV4hm1pFvBUj3uWeyETT-gzGzoHsz',
  appKey:'qQrqv0G0FQYhuLa5PLFpJt0T',
  placeholder:'说些啥呗',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/pk/wallhaven-pkw6y3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 By PrePan</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>